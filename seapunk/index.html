<!DOCTYPE html>
<html lang="en">
	<head>
		<title>S E A P U N K</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #000;
				font-family:Monospace;
				font-size:13px;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				text-align:center;
				padding: 5px;
			}

			a {

				color: #a06851;
			}

		</style>
	</head>e
	<body>
	<div id="info"></div>

		<script src="three.min.js"></script>

		<script src="OrbitControls.js"></script>
		<script src="Mirror.js"></script>
		<script src="WaterShader.js"></script>

		<script src="AnimationClipCreator.js"></script>
		<script src="FlyControls.js"></script>

		<script src="Detector.js"></script>
		<script src="stats.min.js"></script>

		<script>
//VHS Shader https://www.airtightinteractive.com/demos/js/badtvshader/

			if ( ! Detector.webgl ) {

				Detector.addGetWebGLMessage();
				document.getElementById( 'container' ).innerHTML = "";

			}

			var meshGazebo = 0;
			var container, stats;
			var materialGazebo,somGazebo;
			var meshWindowsG,materialWindowsG;

			var camera, scene, renderer, objects;
			var particleLight, pointLight,luzWindows;

			var MARGIN = 0;
			var radius = 6371;
			var SCREEN_HEIGHT = window.innerHeight - MARGIN * 2;
			var SCREEN_WIDTH  = window.innerWidth;

			var clock = new THREE.Clock();
			var mixer = [];
			var controls;
			var quant = 10;
			var waterNormals;
			var mirrorMesh;
			var sphere;
			var golfinhoRot = 0; 
			var meshRosca;
			var roscaPivot;
			var analiser, listener;
			var geometryEsfera, analyserGazebo;
			var meshGb,meshPc;


			var parameters = {
				width: 2000,
				height: 2000,
				widthSegments: 250,
				heightSegments: 250,
				depth: 1500,
				param: 4,
				filterparam: 1
			};

			var waterNormals;
            var pivot;

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				var info = document.createElement( 'div' );
				info.style.position = 'absolute';
				info.style.top = '10px';
				info.style.width = '100%';
				info.style.textAlign = 'center';
				info.innerHTML = 'S A D B O Y S';
				container.appendChild( info );

				//Renderer
				renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				// Stats

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				// Events

				window.addEventListener( 'resize', onWindowResize, false );

				//Scene
				scene = new THREE.Scene();
				//scene.fog = new THREE.FogExp2( 0xFFA966, 0.00012 );

				camera = new THREE.PerspectiveCamera( 25, window.innerWidth / window.innerHeight, 2, 1e7 );
				camera.position.z = radius * 5;
				//camera.position.set( 90, 100, 200 );
				camera.position.set( 0, 15, 0);
				camera.rotation.set(0,-4.5,0);
			

				//Controle wasd
				controls = new THREE.FlyControls( camera );
				controls.movementSpeed = 1000;
				controls.domElement = window.document;
				controls.rollSpeed = Math.PI / 40;
				controls.autoForward = false;
				controls.dragToLook = false;

				// Lights
				scene.add( new THREE.AmbientLight( 0xFFFFFF, 1.5 ) );

				//pointLight = new THREE.PointLight( 0xFFFFFF, 5, 30 );
				pointLight = new THREE.SpotLight( 0xFFA966, 500, 12000 );
				//pointLight.position.set( - 1, 1, - 1 );
				pointLight.position.set(-640,900,-600);
				pointLight.distance = 1255;
				scene.add( pointLight );

				luzWindows = new THREE.PointLight( 0xFFA966, 500, 11000 );
				luzWindows.position.set(5000,1500,1500);
				luzWindows.distance = 1255;
				luzWindows.target = meshWindowsG;
				scene.add( luzWindows );
				

				waterNormals = new THREE.TextureLoader().load( 'waternormals.jpg' );
				waterNormals.wrapS = waterNormals.wrapT = THREE.RepeatWrapping;

				water = new THREE.Water( renderer, camera, scene, {
					textureWidth: 512,
					textureHeight: 512,
					waterNormals: waterNormals,
					alpha: 	1.0,
					sunDirection: pointLight.position.clone().normalize(),
					sunColor: 0xffffff,
					waterColor: 0x6B1C6F,
					distortionScale: 50.0,
				} );


				mirrorMesh = new THREE.Mesh(
					new THREE.PlaneBufferGeometry( parameters.width * 500, parameters.height * 500 ),
					water.material
				);

				mirrorMesh.add( water );
				mirrorMesh.rotation.x = - Math.PI * 0.5;
				scene.add( mirrorMesh );


				// load skybox

				var cubeMap = new THREE.CubeTexture( [] );
				cubeMap.format = THREE.RGBFormat;

				var loader = new THREE.ImageLoader();
				loader.load( 'skyboxsun25degtest.png', function ( image ) {

					var getSide = function ( x, y ) {

						var size = 1024;

						var canvas = document.createElement( 'canvas' );
						canvas.width = size;
						canvas.height = size;

						var context = canvas.getContext( '2d' );
						context.drawImage( image, - x * size, - y * size );

						return canvas;

					};

					cubeMap.images[ 0 ] = getSide( 2, 1 ); // px
					cubeMap.images[ 1 ] = getSide( 0, 1 ); // nx
					cubeMap.images[ 2 ] = getSide( 1, 0 ); // py
					cubeMap.images[ 3 ] = getSide( 1, 2 ); // ny
					cubeMap.images[ 4 ] = getSide( 1, 1 ); // pz
					cubeMap.images[ 5 ] = getSide( 3, 1 ); // nz
					cubeMap.needsUpdate = true;

				} );

				var cubeShader = THREE.ShaderLib[ 'cube' ];
				cubeShader.uniforms[ 'tCube' ].value = cubeMap;

				var skyBoxMaterial = new THREE.ShaderMaterial( {
					fragmentShader: cubeShader.fragmentShader,
					vertexShader: cubeShader.vertexShader,
					uniforms: cubeShader.uniforms,
					depthWrite: false,
					side: THREE.BackSide
				} );

				var skyBox = new THREE.Mesh(
					new THREE.BoxGeometry( 1000000, 1000000, 1000000 ),
					skyBoxMaterial
				);

				scene.add( skyBox );

//MODELOS
				geometryEsfera = new THREE.IcosahedronGeometry( 400, 4 );

				for ( var i = 0, j = geometryEsfera.faces.length; i < j; i ++ ) {

					geometryEsfera.faces[ i ].color.setHex( Math.random() * 0xffffff );

				}

				var material = new THREE.MeshPhongMaterial( {
					vertexColors: THREE.FaceColors,
					shininess: 100,
					envMap: cubeMap
				} );

				sphere = new THREE.Mesh( geometryEsfera, material );
				sphere.position.set( 1000, 28, 1000);		
				scene.add( sphere );

//Gazebo
				var loaderGazebo = new THREE.JSONLoader();
				loaderGazebo.load('json/gazebo.json', function ( geometry, materials ) {

					materialGazebo = materials[ 0 ];
					materialGazebo.morphTargets = true;
				
					var gazeboMaterial = new THREE.MultiMaterial(materials);

						var x = 2;
						var z = 2;

						meshGazebo = new THREE.Mesh( geometry, gazeboMaterial);

						meshGazebo.scale.x = meshGazebo.scale.y = meshGazebo.scale.z = 14.99;
						meshGazebo.position.set( 0, 0, 0);
						meshGazebo.rotation.y= 30;


						meshGazebo.matrixAutoUpdate = false;
						meshGazebo.updateMatrix();
				
						scene.add( meshGazebo );

						listener = new THREE.AudioListener();
						camera.add( listener );

						somGazebo = new THREE.PositionalAudio( listener );
						somGazebo.load( 'audio/Ambiente.mp3' );
						somGazebo.autoplay = true;
						somGazebo.setLoop(true);
						somGazebo.setVolume(0.5);
						somGazebo.setRefDistance( 20 );
						meshGazebo.add(somGazebo);			

						analyserGazebo = new THREE.AudioAnalyser( somGazebo, 32 );
														
				} );

	//Golfinhos
				var loader = new THREE.JSONLoader();
				//loader.load( 'json/novoGol.json', function ( geometry, materials ) {
				loader.load( 'json/paz.json', function ( geometry, materials ) {


					// adjust color a bit

					var material = materials[ 0 ];
					material.morphTargets = true;
				//	material.color.setHex("0x"+Math.floor(Math.ranwdom()*16777215).toString(16));

					var faceMaterial = new THREE.MultiMaterial(materials);

					for ( var i = 0; i < quant; i ++ ) {
						// random placement in a grid

						/*var x = ( ( i % 227 )  - 213.5 ) * 2 + THREE.Math.randFloatSpread( 1 );
						var z = ( Math.floor( i / 227 ) - 213.5 ) * 2 + THREE.Math.randFloatSpread( 1 );*/

						var min = -1000;
						var max = 1000;

						var x = Math.floor((Math.random() * (max-min)) + min + i);
						var z = Math.floor((Math.random() * (max-min)) + min - i);

						// leave space for big monster
						console.log("Posição: X " + x + ", Z " + z);

						if ( Math.abs( x ) < 10 && Math.abs( z ) < 10 ) continue;


						var mesh = new THREE.Mesh(geometry, faceMaterial);
						
						
						mesh.scale.x = mesh.scale.y = mesh.scale.z = 8.29;

						mesh.position.set( x, 40, z );
						mesh.rotation.y = THREE.Math.randFloat( -0.25, 0.25 );



						mesh.matrixAutoUpdate = false;
						mesh.updateMatrix();

						scene.add( mesh );

						mixer[i] = new THREE.AnimationMixer( mesh );
						var clip = THREE.AnimationClip.CreateFromMorphTargetSequence( 'mexe', geometry.morphTargets, 30 );
						mixer[i].clipAction( clip ).setDuration( 1 ).play();

					}
				} );

//Rosca
				var loaderRosca = new THREE.JSONLoader();
				loaderRosca.load( 'json/rosca.json', function ( geometry, materials ) {

					var material = materials[ 0 ];
					material.morphTargets = true;

					var faceMaterial = new THREE.MultiMaterial(materials);

					meshRosca = new THREE.Mesh(geometry, faceMaterial);
						
					meshRosca.scale.x = meshRosca.scale.y = meshRosca.scale.z = 19.29;
					meshRosca.position.set( -500, 80, 70);
					meshRosca.rotation.set(11.199999999999992,22.00000000000003,36.000000000000014);
					
										
					//meshRosca.matrixAutoUpdate = false;
					//meshRosca.updateMatrix();

					scene.add( meshRosca );
										
				} );
//Windows gigante
var loaderWindowsG = new THREE.JSONLoader();
				loaderWindowsG.load( 'json/windows.json', function ( geometry, materials ) {

					var material = materials[ 0 ];
					material.morphTargets = true;

					materialWindowsG = new THREE.MultiMaterial(materials);

					meshWindowsG = new THREE.Mesh(geometry, materialWindowsG);
						
					meshWindowsG.scale.x = meshWindowsG.scale.y = meshWindowsG.scale.z = 466.29;
					meshWindowsG.position.set(-5000,1500,1500);
					meshWindowsG.rotation.x = 80.1;
					meshWindowsG.rotation.z = 80.1;
										
					scene.add( meshWindowsG );
										
				} );				

//Golfinho rosca
var loader = new THREE.JSONLoader();
				loader.load( 'json/golfinho.json', function ( geometry, materials ) {

					// adjust color a bit


					var material = materials[ 0 ];
					material.morphTargets = true;
					material.color.setHex("0x"+Math.floor(Math.random()*16777215).toString(16));

					var faceMaterial = new THREE.MultiMaterial(materials);


						golfinhoRot = new THREE.Mesh(geometry, faceMaterial);
						
						
						golfinhoRot.scale.x = golfinhoRot.scale.y = golfinhoRot.scale.z = 109.9;

						golfinhoRot.position.set( -500, 80, 70);
						golfinhoRot.rotation.set(9,11,0);

						//Rotacao do golfinho
                        scene.add( golfinhoRot );

                        pivot = new THREE.Object3D();
                        pivot.position.set(-480, 2.6000000000001364, 53.5);
                        pivot.scale.x = pivot.scale.y = pivot.scale.z = 2.2900000000000023;
                        pivot.add(golfinhoRot);
                        scene.add(pivot);

						mixer[i] = new THREE.AnimationMixer( golfinhoRot );
						var clip = THREE.AnimationClip.CreateFromMorphTargetSequence( 'mexe', geometry.morphTargets, 30 );
						mixer[i].clipAction( clip ).setDuration( 1 ).play();

					});


//GAMEBOY
				var loaderGb = new THREE.JSONLoader();
				loaderGb.load( 'json/gameboy.json', function ( geometry, materials ) {

					var material = materials[ 0 ];
					material.morphTargets = true;

					var faceMaterial = new THREE.MultiMaterial(materials);

					meshGb = new THREE.Mesh(geometry, faceMaterial);
						
					meshGb.scale.x = meshGb.scale.y = meshGb.scale.z = 1.7900000000000023;
					meshGb.position.set( -36.5, 14.5, 22);
					meshGb.rotation.set(8.881784197001252e-16,4.799999999999999,1.4);
					

										
					//meshRosca.matrixAutoUpdate = false;
					//meshRosca.updateMatrix();

					scene.add( meshGb );
										
				} );

//COMPUTADOR
                var loaderPc = new THREE.JSONLoader();
                loaderPc.load( 'json/computador.json', function ( geometry, materials ) {

                    var material = materials[ 0 ];
                    material.morphTargets = true;

                    var faceMaterial = new THREE.MultiMaterial(materials);

                    meshPc = new THREE.Mesh(geometry, faceMaterial);
                        
                    meshPc.scale.x = meshPc.scale.y = meshPc.scale.z = 2.2900000000000027;
                    meshPc.position.set( -41.40000000000007, 13.499999999999998, -8.200000000000024);
                    meshPc.rotation.set(0,0,0);
                
                    scene.add( meshPc );
                                        
                } );


//Sons
				

			}

			//

			function onWindowResize( event ) {

				renderer.setSize( window.innerWidth, window.innerHeight );

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
			}



			var prevTime = performance.now();

			function render() {

				var time = performance.now() * 0.001;
				var delta = clock.getDelta();

				sphere.position.y = Math.sin( time ) * 500 + 250;
				sphere.rotation.x = time * 0.5;
				sphere.rotation.z = time * 0.51;

				/*golfinhoRot.rotation.x = time * 0.21;
				golfinhoRot.position.y = Math.sin( time ) * 25 + 25;
				golfinhoRot.position.x = Math.sin( time ) * 10 + 10;
				console.log("Depois do golfinho");*/

				//meshGazebo.position.z = time * 0.5;
				

				//Animando golfinhos
			//	var time = Date.now();
	//console.log("Quantidade de objetos animados: " + mixer.length);
				for ( var i = 0; i <= mixer.length; i ++ ) {
					
					if ( mixer[i] ) {
						//mixer[i].update( ( time - prevTime ) * 0.001 );
						mixer[i].update( ( delta));
				}

			}
				//agua
				water.material.uniforms.time.value += 1.0 / 60.0;
				
				controls.movementSpeed = 100.33;
				controls.update(delta);


                pivot.rotation.z -= 1.0 / 60.0;
                golfinhoRot.rotation.z -= 1.0 / 60.0;
                golfinhoRot.rotation.y -= 1.0 / 60.0;
                
				
				//geometryEsfera.emissive.b = analyserEsfera.getData()[8] / 256;
				


				water.render();
				renderer.render( scene, camera );

			}

			function animate() {

				requestAnimationFrame( animate );
				render();
				stats.update();
			}

			init();
			animate();

		</script>
	</body>
</html>
